"use strict";
/*
 * @adonisjs/lucid
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../adonis-typings/index.ts" />
const utils_1 = require("@poppinss/utils");
/**
 * Ensure that relation is defined
 */
function ensureRelation(name, relation) {
    if (!relation) {
        throw new utils_1.Exception(`Cannot process unregistered relationship ${name}`, 500);
    }
    return true;
}
exports.ensureRelation = ensureRelation;
/**
 * Ensure a key value is not null or undefined inside an object.
 */
function ensureValue(collection, key, missingCallback) {
    const value = collection[key];
    if (value === undefined || value === null) {
        missingCallback();
        return;
    }
    return value;
}
exports.ensureValue = ensureValue;
/**
 * Raises exception when a relationship `booted` property is false.
 */
function ensureRelationIsBooted(relation) {
    if (!relation.booted) {
        throw new utils_1.Exception('Relationship is not booted. Make sure to call boot first', 500, 'E_RUNTIME_EXCEPTION');
    }
}
exports.ensureRelationIsBooted = ensureRelationIsBooted;
/**
 * Returns the value for a key from the model instance and raises descriptive
 * exception when the value is missing
 */
function getValue(model, key, relation, action = 'preload') {
    return ensureValue(model, key, () => {
        throw new utils_1.Exception(`Cannot ${action} "${relation.relationName}", value of "${relation.model.name}.${key}" is undefined`, 500);
    });
}
exports.getValue = getValue;
/**
 * Helper to find if value is a valid Object or
 * not
 */
function isObject(value) {
    return value !== null && typeof (value) === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
/**
 * Drops duplicate values from an array
 */
function unique(value) {
    if (!Array.isArray(value)) {
        return [];
    }
    return [...new Set(value)];
}
exports.unique = unique;
/**
 * Returns a diff of rows to be updated or inserted when performing
 * a many to many `attach`
 */
function syncDiff(original, incoming) {
    const diff = Object
        .keys(incoming)
        .reduce((result, incomingRowId) => {
        const originalRow = original[incomingRowId];
        const incomingRow = incoming[incomingRowId];
        /**
         * When there isn't any matching row, we need to insert
         * the upcoming row
         */
        if (!originalRow) {
            result.added[incomingRowId] = incoming[incomingRowId];
        }
        else if (Object.keys(incomingRow).find((key) => incomingRow[key] !== originalRow[key])) {
            /**
             * If any of the row attributes are different, then we must
             * update that row
             */
            result.updated[incomingRowId] = incoming[incomingRowId];
        }
        return result;
    }, { added: {}, updated: {} });
    return diff;
}
exports.syncDiff = syncDiff;
/**
 * Invokes a callback by wrapping it inside managed transaction
 * when passed client is not transaction itself.
 */
async function managedTransaction(client, callback) {
    const isManagedTransaction = !client.isTransaction;
    const trx = client.isTransaction ? client : await client.transaction();
    if (!isManagedTransaction) {
        return callback(trx);
    }
    try {
        const response = await callback(trx);
        await trx.commit();
        return response;
    }
    catch (error) {
        await trx.rollback();
        throw error;
    }
}
exports.managedTransaction = managedTransaction;
